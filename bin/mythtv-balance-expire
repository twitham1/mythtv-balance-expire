#!/usr/bin/perl -w

# mythtv-balance-expire by twitham@sbcglobal.net, 2017-02-18

# All disks must have expiring recordings, ideally from the full range
# of recorded time so that only oldest recordings are expired.  This
# distributes expirable recordings evenly over all disks and time.  If
# a move makes a disk fuller than the last, then a swap with a keeper
# of closest size is done to keep balanced headroom.  Assumptions: all
# files are local.  Tested with 2 disks but should work with any.

use warnings;
use MythTV;
use Getopt::Long;

my %opt = (delta => 5);	       # lower = better balance but more moves
my $usage = "usage: $0 [options]
--delta=N	expiring count delta allowed between disks [$opt{delta}]
		lower = better balance, higher = less moves
	hint: --delta 9999 to see current expiring balance w/no moves
--subtitles	add subtitles to titles of moving files
--verbose	show the commands that would be run, or are being run:
--go		actually do the moves, else just show what would be done
";
GetOptions(\%opt, qw(delta=i subtitles verbose go)) or die $usage;

# How to copy the files.  If successful, originals are unlinked
my @copy = qw/ionice -n 7 nice rsync -a/; # must exit 0 on success only
push @copy, '--progress' if -t STDIN;
my $RECENT = time - 3 * 24 * 60 * 60; # don't move recent files
my $MAX = 0.7;			# maximum free space to use for copies
my $KB = 1024;
my $MB = $KB * $KB;
my $GB = $MB * $KB;
my @exp;			# ordered expiring basenames
my %keep;			# {dir}{keeping basenames}
my %size;			# {basename} = bytes in file
my %title;			# {basename} = title [/ subtitle]
my %where;			# {basename} = dir
my %done;			# {dir}{basename} = 1, final locations
my %free;			# {dir} = bytes free on disk
my %count = qw/< 0 > 0/;	# {type} = count of moves

my $myth = new MythTV();   # we'll keep expires in chronological order:
my %rows = $myth->backend_rows('QUERY_RECORDINGS Ascending');

foreach my $row (@{$rows{'rows'}}) { # gather status and location of shows
    my $show = $myth->new_recording(@$row);
    my $key = $show->{basename};
    my $path = $show->{local_path};
    (my $dir = $path) =~ s@/[^/]+$@@;
    $dir =~ m@/@ or next;	# only old files in a local path
    $show->{lastmodified} < $RECENT or next;
    $size{$key} = $show->{filesize};
    $title{$key} = $show->{title};
    $opt{subtitles} and $title{$key} .= " / $show->{subtitle}";
    $where{$key} = $dir;
    $show->{auto_expire} ? push @exp, $key : $keep{$dir}{$key}++;
    $done{$dir} or $done{$dir} = { one => 1 };
}

my @path = sort keys %done;	# storage paths found
@path > 1 or die "need 2 or more paths to balance, found: @path\n";
my $n = 1;
for my $dir (@path) {		# per-disk metrics
    $n{$dir} = $n++;		# disk number, for indent columns
    $free{$dir} = &free($dir) * $KB; # bytes free, updated by &move
}

for my $move (@exp) {		# expirables in time order
    my @p = sort { keys %{$done{$a}} <=> keys %{$done{$b}} } @path;
    my $more = pop @p;		# path with most expires
    my $less = shift @p;	# path with least expires
    my $exp = scalar keys %{$done{$where{$move}}};
    print "\t" x $n{$where{$move}}, $move, "\t$where{$move}\t$exp\n";
    unless ($where{$move} eq $more) { # keep it here if not path of most
	$done{$where{$move}}{$move}++;
	next;
    }
    if ((keys %{$done{$more}}) - (keys %{$done{$less}}) < $opt{delta}) {
	$done{$more}{$move}++;	# balanced, keep it here
	next;
    }
    my $code = &move($more, $less, $move, '<'); # move expiring file
    $code < 0 and last;		# bail out on copy error
    $code > 0 or ++$done{$more}{$move} and next; # keep going on file skip
    $done{$less}{$move}++;	# record the move to new disk

    # auto-balance uneven disks by deciding if keeper trade is needed
    int($free{$less} / $GB) >= int($free{$more} / $GB) and next;

    # trade keeper file of closest size
    my $find = $size{$move};
    my $swap = (sort { abs($size{$a} - $find) <=>
			   abs($size{$b} - $find) } keys %{$keep{$less}})[0];
    $swap or
	print "no file available for swap, continuing\n"
	and next;
    $code = &move($less, $more, $swap, '>'); # move keeper file
    $code < 1 and last;
    $keep{$more}{$swap}++; delete $keep{$less}{$swap}; # record move
}
$opt{go} or
    print "NOTHING DONE!  Add --go to actually move <",
    $count{'<'}, " expires< and >", $count{'>'}, " keepers>.\n";

sub move {		 # -1 = copy error, 0 = skip, 1 = copy success
    my($src, $dst, $file, $which) = @_;
    my $free = $free{$dst};
    if ($size{$file} > $free * $MAX) { # file too big?
	printf "skipping %.3f GB $file > %.3f * $MAX free on $dst | %s\n",
	$size{$file} / $GB, $free / $GB, $title{$file};
	return 0;
    }
    if ($opt{go}) {		# actual disk headrooms
	$free{$src} = &free($src) * $KB;
	$free{$dst} = &free($dst) * $KB;
    } else {			# estimated disk headrooms
	$free{$src} += $size{$file};
	$free{$dst} -= $size{$file};
    }
    printf "$which %7.3f $file: $src -> $dst %4d %7.3f $which %s\n",
    $size{$file} / $GB, scalar(keys %{$done{$dst}}), $free / $GB, $title{$file};

    my @src = glob "$src/${file}*"; # list includes thumbnails
    my @cmd = (@copy, @src, "$dst/");
    $opt{verbose} and print "@cmd\n";
    if ($opt{go}) {		# actually do copy and unlink
	system(@cmd) == 0
	    or warn sprintf("exit %d from (@cmd)\n", $? >> 8)
	    and return -1;
	map { unlink $_ or warn "could not unlink $_: $!\n" } @src;
    }
    $count{$which}++;
    return 1;			# only if copy successful
}

sub free { return (&df(shift))[3]; } # free space of path in KB

sub df {			# df of $file in KB
    my($file) = @_;
    my @out = split "\n", `df -k $file`;
    return split /\s+/, $out[-1];
}
