#!/usr/bin/perl -w

# mythtv-balance-expire by twitham@sbcglobal.net, 2017-02-18

# All disks must have expiring recordings, ideally from the full range
# of recorded time.  This moves oldest expiration from disk with the
# most to disk with the least and trades it for the keeper of closest
# size.  Repeats swaps until expirations are better distributed on all
# disks.  Exits when there are no files small enough for swap in the
# available space.  Assumptions: all files are local.  Tested with 2
# local disks but should work with any amount.

# TODO: for new disks, move keepers until balanced headroom

use warnings;
use MythTV;
use Getopt::Long;

my $usage = "usage: $0 [options]
--notrade	only move expires, with no trade (use for new disks)
--verbose	show the commands that would be run, or are being run:
--go		actually do the moves, else just show what would be done
";
GetOptions(\%opt, qw(go verbose notrade)) or die $usage;

# How to copy the files.  If successful, originals are unlinked
my @copy = qw/ionice -n 7 nice rsync -a/; # must exit 0 on success only
push @copy, '--progress' if -t STDIN;
my $RECENT = time - 3 * 24 * 60 * 60; # don't move recent files
my $MAX = 0.7;			# maximum free space to use for copies
my $KB = 1024;
my $MB = $KB * $KB;
my $GB = $MB * $KB;
my %exp;			# {dir}[ordered expiring basenames]
my %keep;			# {dir}{keeping basenames}
my %size;			# {basename} = bytes in file
my %title;			# {basename} = "title / subtitle"
my %moved;			# {dir} = bytes moved per disk

my $myth = new MythTV();   # we'll keep expires in chronological order:
my %rows = $myth->backend_rows('QUERY_RECORDINGS Ascending');

foreach my $row (@{$rows{'rows'}}) { # gather status and location of shows
    my $show = $myth->new_recording(@$row);
    my $key = $show->{basename};
    my $path = $show->{local_path};
    (my $dir = $path) =~ s@/[^/]+$@@;
    $dir =~ m@/@ or next;	# only old files in a local path
    $show->{lastmodified} < $RECENT or next;
    $show->{auto_expire} ? (push @{$exp{$dir}}, $key) : $keep{$dir}{$key}++;
    $size{$key} = $show->{filesize};
    $title{$key} = "$show->{title} / $show->{subtitle}";
}

my $n = my @path = keys %exp;	# storage paths found
$n > 1 or die "need 2 or more paths to balance, found: @path\n";

my $exp = 0; map { $exp += @{$exp{$_}} } @path;
my $goal = int($exp / $n);	# expires per disk, ideal

while (1) {			# "last" will exit
    my @p = sort { @{$exp{$a}} <=> @{$exp{$b}} } @path;
    my $more = pop @p;		# path with more expires
    my $less = shift @p;	# path with less expires
    my $nmore = @{$exp{$more}};	# count of expires
    my $nless = @{$exp{$less}};

    last			# done if balanced!
	if $nless >= $goal or $nmore <= $goal;

    # keep similar age per disk by skipping alternate expires
    push@{$exp{$more}}, shift @{$exp{$more}};

    # assume oldest expire is best candidate for move
    my $move = shift @{$exp{$more}} or
	print "nothing left to move, exiting\n"
	and last;
    my $code = &move($more, $less, $move, '<'); # move expiring file
    $code < 0 and last;		# bail out on copy error
    $code > 0 or next;		# keep going on file skip
    push @{$exp{$less}}, $move;	# record the move to new disk

    $opt{notrade} and next;

    # trade keeper file closest to sum moved bytes for this disk
    my $find = $moved{$less};	# global sum is set by &move below
    my $swap = (sort { abs($size{$a} - $find) <=>
			   abs($size{$b} - $find) } keys %{$keep{$less}})[0];
    $swap or
	print "nothing left to swap, exiting\n"
	and last;
    $code = &move($less, $more, $swap, '>'); # move keeper file
    $code < 1 and last;
    $keep{$more}{$swap}++; delete $keep{$less}{$swap}; # record move
}
$opt{go} or
    print "NOTHING DONE!  Add --go to actually do the trades.\n";

sub move {		 # -1 = copy error, 0 = skip, 1 = copy success
    my($src, $dst, $file, $which) = @_;
    my $free = &free($dst) * $KB; # actual disk headrooms
    unless ($opt{go}) {		  # estimated disk headrooms
    	$free{$dst} ||= $free;
    	$free{$src} ||= &free($src) * $KB;
    	$free{$src} += $size{$file};
    	$free = $free{$dst} -= $size{$file};
    }
    if ($size{$file} > $free * $MAX) { # file too big?
	printf "skipping %.3f GB $file > %.3f * $MAX free on $dst | %s\n",
	$size{$file} / $GB, $free / $GB, $title{$file};
	return 0;
    }
    printf "$which %7.3f $file: $src -> $dst %6.3f %4d $which %s\n",
    $size{$file} / $GB, $free / $GB, scalar(@{$exp{$dst}}), $title{$file};

    my @src = glob "$src/${file}*"; # list includes thumbnails
    my @cmd = (@copy, @src, "$dst/");
    $opt{verbose} and print "@cmd\n";
    if ($opt{go}) {		# actually do copy and unlink
	system(@cmd) == 0
	    or warn sprintf("exit %d from (@cmd)\n", $? >> 8)
	    and return -1;
	map { unlink $_ or warn "could not unlink $_: $!\n" } @src;
    }
    $moved{$src} -= $size{$file}; # global: sum bytes moved per disk
    $moved{$dst} += $size{$file};
    return 1;			# only if copy successful
}

sub free { return (&df(shift))[3]; } # free space of path in KB

sub df {			# df of $file in KB
    my($file) = @_;
    my @out = split "\n", `df -k $file`;
    return split /\s+/, $out[-1];
}
